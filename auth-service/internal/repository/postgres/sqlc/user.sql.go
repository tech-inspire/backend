// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const clearUserAvatarURL = `-- name: ClearUserAvatarURL :exec
UPDATE users SET avatar_url = NULL WHERE user_id = $1
`

func (q *Queries) ClearUserAvatarURL(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearUserAvatarURL, userID)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (user_id, email, name, username, password_hash, description, avatar_url)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateUserParams struct {
	UserID       uuid.UUID `db:"user_id"`
	Email        string    `db:"email"`
	Name         string    `db:"name"`
	Username     string    `db:"username"`
	PasswordHash []byte    `db:"password_hash"`
	Description  string    `db:"description"`
	AvatarUrl    *string   `db:"avatar_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.UserID,
		arg.Email,
		arg.Name,
		arg.Username,
		arg.PasswordHash,
		arg.Description,
		arg.AvatarUrl,
	)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
DELETE
FROM users
WHERE user_id = $1
`

func (q *Queries) DeleteUserByID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserByID, userID)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT users.user_id, users.email, users.username, users.name, users.description, users.avatar_url, users.password_hash, users.is_admin, users.created_at, users.updated_at
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	User User `db:"user"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.Email,
		&i.User.Username,
		&i.User.Name,
		&i.User.Description,
		&i.User.AvatarUrl,
		&i.User.PasswordHash,
		&i.User.IsAdmin,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT users.user_id, users.email, users.username, users.name, users.description, users.avatar_url, users.password_hash, users.is_admin, users.created_at, users.updated_at
FROM users
WHERE users.user_id = $1
`

type GetUserByIDRow struct {
	User User `db:"user"`
}

func (q *Queries) GetUserByID(ctx context.Context, userID uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.Email,
		&i.User.Username,
		&i.User.Name,
		&i.User.Description,
		&i.User.AvatarUrl,
		&i.User.PasswordHash,
		&i.User.IsAdmin,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT users.user_id, users.email, users.username, users.name, users.description, users.avatar_url, users.password_hash, users.is_admin, users.created_at, users.updated_at
FROM users
WHERE username = $1
`

type GetUserByUsernameRow struct {
	User User `db:"user"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.Email,
		&i.User.Username,
		&i.User.Name,
		&i.User.Description,
		&i.User.AvatarUrl,
		&i.User.PasswordHash,
		&i.User.IsAdmin,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
	)
	return i, err
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT users.user_id, users.email, users.username, users.name, users.description, users.avatar_url, users.password_hash, users.is_admin, users.created_at, users.updated_at
FROM users
WHERE users.user_id = ANY ($1::uuid[])
`

type GetUsersByIDsRow struct {
	User User `db:"user"`
}

func (q *Queries) GetUsersByIDs(ctx context.Context, userIds []uuid.UUID) ([]GetUsersByIDsRow, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs, userIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByIDsRow{}
	for rows.Next() {
		var i GetUsersByIDsRow
		if err := rows.Scan(
			&i.User.UserID,
			&i.User.Email,
			&i.User.Username,
			&i.User.Name,
			&i.User.Description,
			&i.User.AvatarUrl,
			&i.User.PasswordHash,
			&i.User.IsAdmin,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserByID = `-- name: UpdateUserByID :exec
UPDATE users
SET name          = COALESCE($1, name),
    password_hash = COALESCE($2, password_hash),
    username      = COALESCE($3, username),
    description   = COALESCE($4, description),
    avatar_url    = COALESCE($5, avatar_url),
    updated_at    = NOW()
WHERE user_id = $6
`

type UpdateUserByIDParams struct {
	Name         *string   `db:"name"`
	PasswordHash []byte    `db:"password_hash"`
	Username     *string   `db:"username"`
	Description  *string   `db:"description"`
	AvatarUrl    *string   `db:"avatar_url"`
	UserID       uuid.UUID `db:"user_id"`
}

func (q *Queries) UpdateUserByID(ctx context.Context, arg UpdateUserByIDParams) error {
	_, err := q.db.Exec(ctx, updateUserByID,
		arg.Name,
		arg.PasswordHash,
		arg.Username,
		arg.Description,
		arg.AvatarUrl,
		arg.UserID,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $1,
    updated_at    = NOW()
WHERE user_id = $2
`

func (q *Queries) UpdateUserPassword(ctx context.Context, passwordHash []byte, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateUserPassword, passwordHash, userID)
	return err
}
